#nullable enable
using System.Collections.Concurrent;
using System.Text;
using Bogus;
using GovUk.Education.ExploreEducationStatistics.Common.Extensions;

namespace GovUk.Education.ExploreEducationStatistics.Common.Tests.Fixtures;

/// <summary>
/// A context for test data generators, providing deterministic local seeding
/// of <see cref="Bogus.Faker"/> instances.
/// </summary>
/// <seealso href="https://github.com/bchavez/Bogus#determinism"/>
public class DataFixture
{
    private readonly int _seedFrom;
    private readonly ConcurrentDictionary<Type, int> _seeds = new();

    private int _index = -1;
    private readonly ConcurrentDictionary<Type, int> _typeIndices = new();

    public DataFixture(int seedFrom = 0)
    {
        _seedFrom = seedFrom;
    }

    /// <summary>
    /// Create a new <see cref="Generator{T}"/> to produce test data.
    /// </summary>
    /// <param name="locale">Locale for textual data. Defaults to English.</param>
    public Generator<T> Generator<T>(string locale = "en")
        where T : class
    {
        return new Generator<T>(
            faker: new Faker(locale),
            fixture: this,
            seeder: () =>
            {
                return _seeds.AddOrUpdate(
                    key: typeof(T),
                    addValue: GenerateUniqueStartingSeedForType<T>(_seedFrom),
                    updateValueFactory: (_, current) => current + 1
                );
            }
        );
    }

    /// <summary>
    /// Set a custom seed value for the specified type, modifying
    /// the data that is randomly generated.
    /// </summary>
    /// <param name="seed">The seed value.</param>
    /// <seealso href="https://github.com/bchavez/Bogus#determinism"/>
    public DataFixture SetSeed<T>(int seed)
        where T : class
    {
        _seeds.AddOrUpdate(key: typeof(T), addValue: seed, updateValueFactory: (_, _) => seed);
        return this;
    }

    /// <summary>
    /// Increment the type's index in this fixture, returning the new index.
    /// </summary>
    internal int NextTypeIndex<T>() =>
        _typeIndices.AddOrUpdate(
            key: typeof(T),
            addValue: 0,
            updateValueFactory: (_, current) => current + 1
        );

    /// <summary>
    /// Increment the index of all types generated by this fixture, returning the new index.
    /// </summary>
    internal int NextIndex() => Interlocked.Increment(ref _index);

    // Generate a unique line of random values per Type that we are generating.
    // This allows us to have consistency in the "random" values that Faker is providing
    // (i.e. the first 10 random Guids generated by faker.Random.Guid() for a Release
    // will always be consistent values whilst still providing variation) but will help to
    // avoid conflicting random values between types (i.e. the first 10 random Guids generated
    // by faker.Random.Guid() for a Publication will not be the same as those for the first 10
    // Releases).
    //
    // This also allows us to avoid producing invalid data e.g. avoiding the first generated
    // HtmlBlock from having the same Id as the first generated DataBlock, which in a TPT
    // hierarchy would be invalid).
    private static int GenerateUniqueStartingSeedForType<T>(int seedFrom)
        where T : class
    {
        var md5HashInBytes = Encoding.UTF8.GetBytes(typeof(T).GetPrettyFullName().ToMd5Hash());
        return seedFrom + BitConverter.ToInt32(md5HashInBytes, 0);
    }
}
